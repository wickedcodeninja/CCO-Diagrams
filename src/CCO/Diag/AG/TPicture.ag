imports
{
import CCO.Picture
}

data Root | Root d :: Diag

attr Diag_ Diag 
  inh right :: {Double}
  inh bottom_left :: {(Double, Double)}
  syn pic :: {Commands}
  syn new_right :: {Double}
  syn new_bottom_left :: {(Double, Double)}

attr Root
  syn pic :: {Picture}

sem Root | Root lhs.pic = Picture (0,0) @d.pic
                  d.right = 0
                  d.bottom_left = (0,0)

sem Diag | Diag lhs.pic = @d.pic
                d.max_right = 0
                d.right = @lhs.right
                d.bottom_left = @lhs.bottom_left
                lhs.new_bottom_left = @d.new_bottom_left

sem Diag_
  | Program lhs.pic = mkProgram (@lhs.right,snd @lhs.bottom_left) @p @l
            loc.temp_right = fst @lhs.bottom_left + 65
            lhs.new_right = @loc.temp_right - 7.5
            lhs.new_bottom_left = (fst @lhs.bottom_left + 7.5, snd @lhs.bottom_left)
  | Platform lhs.pic = mkPlatform (@lhs.right,0) @m
             lhs.new_right = 0
             lhs.new_bottom_left = (0,0)
  | Interpreter lhs.pic = mkInterpreter (@lhs.right,snd @lhs.bottom_left) @i @l @m
                lhs.new_right = 0
                lhs.new_bottom_left = (0,0)
  | Compiler lhs.pic = mkCompiler (@lhs.right,0) @c @l1 @l2 @m
             lhs.new_right = 0
             lhs.new_bottom_left = (0,0)
  | Execute lhs.pic = @d1.pic ++ @d2.pic
     d1.bottom_left = @lhs.bottom_left
     d2.bottom_left = (@d1.new_right, snd @lhs.bottom_left)
     lhs.new_bottom_left = @d2.new_bottom_left
     lhs.new_right = @d2.new_right
  | Compile lhs.pic = @d1.pic ++ @d2.pic
            lhs.new_right = 0
            lhs.new_bottom_left = (0,0)


{
mkProgram :: (Double, Double) -> String -> String -> Commands
mkProgram (x,y) p l = [
                       Put (x+7.5,y+0) (Line (1,0) 50),
                       Put (x+7.5,y+0) (Line (0,1) 15),
                       Put (x+7.5,y+15) (Line (-1,2) 7.5),
                       Put (x+57.5,y+15) (Line (1,2) 7.5),
                       Put (x+57.5,y+0) (Line (0,1) 15),
                       Put (x+0,y+30) (Line (1,0) 65),
                       Put (x+7.5,y+15) (Makebox (50,15) p),
                       Put (x+7.5,y+0) (Makebox (50,15) l)
                      ]

mkPlatform :: (Double, Double) -> String -> Commands
mkPlatform (x,y) m = [
                      Put (x+0,y+15) (Line (5,-3) 25),
                      Put (x+25,y+0) (Line (5,3) 25),
                      Put (x+0,y+15) (Line (0,1) 15),
                      Put (x+0,y+30) (Line (1,0) 50),
                      Put (x+50,y+30) (Line (0,-1) 15),
                      Put (x+0,y+15) (Makebox (50,15) m)
                     ]

mkInterpreter :: (Double, Double) -> String -> String -> String -> Commands
mkInterpreter (x,y) i l m = [
                             Put (x+0,y+0) (Framebox (50,30) ""),
                             Put (x+0,y+20) (Makebox (50,10) l),
                             Put (x+0,y+10) (Makebox (50,10) i),
                             Put (x+0,y+0) (Makebox (50,10) m)
                            ]

mkCompiler :: (Double, Double) -> String -> String -> String -> String -> Commands
mkCompiler (x,y) c l1 l2 m = [
                              Put (x+50,y+0) (Line (0,1) 20),
                              Put (x+50,y+20) (Line (-1,0) 50),
                              Put (x+0,y+20) (Line (0,1) 10),
                              Put (x+0,y+30) (Line (1,0) 150),
                              Put (x+150,y+30) (Line (0,-1) 10),
                              Put (x+150,y+20) (Line (-1,0) 50),
                              Put (x+100,y+20) (Line (0,-1) 20),
                              Put (x+100,y+0) (Line (-1,0) 50),
                              Put (x+0,y+20) (Makebox (50,10) l1),
                              Put (x+50,y+20) (Makebox (50,10) "$\\longrightarrow$"),
                              Put (x+100,y+20) (Makebox (50,10) l2),
                              Put (x+50,y+10) (Makebox (50,10) c),
                              Put (x+50,y+0) (Makebox (50,10) m)
                             ]


}

{
pic_Root :: Root -> Picture
pic_Root root = pic_Syn_Root (wrap_Root (sem_Root root) Inh_Root)
}