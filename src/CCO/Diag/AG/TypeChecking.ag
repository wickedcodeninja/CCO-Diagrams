-- (C) 2017 Wout Elsinghorst

imports
{
import CCO.Printing

import Data.Maybe
}

{
type Language = String
type SourceAndTargetLanguage = (Language, Language)

data MessageType = Error | Warning
type Message = (MessageType, String)
}


attr Diag Diag_
  syn   typeDiagnostics :: { [Message] }
  syn   isWrittenInLanguage :: { Maybe Language }
  syn   canExecuteLanguage  :: { Maybe Language }
  syn   canCompileLanguage  :: { Maybe SourceAndTargetLanguage }
 
attr Diag_ 
  inh  pos :: { SourcePos }
 
sem Diag_
  | Program     lhs.typeDiagnostics = []
  | Compiler    lhs.typeDiagnostics = []
  
  | Platform    lhs.typeDiagnostics = []
  | Interpreter lhs.typeDiagnostics = []
      
  | Execute     lhs.typeDiagnostics = @d1.typeDiagnostics ++ @d2.typeDiagnostics ++ tcExecute @lhs.pos @d1.isWrittenInLanguage @d2.canExecuteLanguage
  | Compile     lhs.typeDiagnostics = @d1.typeDiagnostics ++ @d2.typeDiagnostics ++ tcCompile @lhs.pos @d1.isWrittenInLanguage (fmap fst @d2.canCompileLanguage)

sem Diag_
  | Program     lhs.canExecuteLanguage = Nothing
  | Compiler    lhs.canExecuteLanguage = Nothing
  
  | Platform    lhs.canExecuteLanguage = Just @m
  | Interpreter lhs.canExecuteLanguage = Just @l
      
  | Execute     lhs.canExecuteLanguage = @d1.canExecuteLanguage
  | Compile     lhs.canExecuteLanguage = @d1.canExecuteLanguage

sem Diag_
  | Program     lhs.canCompileLanguage = Nothing
  | Compiler    lhs.canCompileLanguage = Just (@l1, @l2)
  
  | Platform    lhs.canCompileLanguage = Nothing
  | Interpreter lhs.canCompileLanguage = Nothing
      
  | Execute     lhs.canCompileLanguage = @d1.canCompileLanguage
  | Compile     lhs.canCompileLanguage = @d1.canCompileLanguage
  
sem Diag_
  | Program     lhs.isWrittenInLanguage = Just @l
  | Compiler    lhs.isWrittenInLanguage = Just @m
  
  | Platform    lhs.isWrittenInLanguage = Nothing
  | Interpreter lhs.isWrittenInLanguage = Just @m
      
  | Execute     lhs.isWrittenInLanguage = @d2.isWrittenInLanguage
  | Compile     lhs.isWrittenInLanguage = fmap snd @d2.canCompileLanguage
                                            
sem Diag
  | Diag      lhs.diagramType         = @d.diagramType
  | Diag      lhs.isWrittenInLanguage = @d.isWrittenInLanguage
  | Diag      lhs.canExecuteLanguage  = @d.canExecuteLanguage
  | Diag      lhs.isTypeCorrect       = @d.isTypeCorrect
  
  | Diag      d.pos                   = @pos
  
{

tcCompile :: SourcePos -> Maybe Language -> Maybe Language -> [(MessageType, String)]
tcCompile = tcConnector "Compile"

tcExecute :: SourcePos -> Maybe Language -> Maybe Language -> [(MessageType, String)]
tcExecute = tcConnector "Execute"

tcConnector :: String -> SourcePos -> Maybe Language -> Maybe Language -> [(MessageType, String)]
tcConnector typ pos source target = 
  let hasSourceLanguage = 
        case source of
          Nothing -> [(Error, typ ++ ": First diagram has missing implementation language.")]
          _       -> []
  
      hasTargetLanguage = 
        case target of
          Nothing -> [(Error, typ ++ ": Second diagram is not a suitable target.")]
          _       -> []
          
      sourceAndTargetLanguageMatch = 
          case (source, target) of
            (Just l1, Just l2 ) | l1 /= l2 -> [(Error, typ ++ ": Source language '" ++ l1 ++ "' does not match target language '" ++ l2 ++ "'")]
            _                              -> []
  in hasSourceLanguage ++ hasTargetLanguage ++ sourceAndTargetLanguageMatch
}

  
{
getTypeDiagnostics :: Diag -> [Message]
getTypeDiagnostics diag = typeDiagnostics_Syn_Diag (wrap_Diag (sem_Diag diag) Inh_Diag)
}
