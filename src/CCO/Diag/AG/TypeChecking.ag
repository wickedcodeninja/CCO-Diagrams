-- (C) 2017 Wout Elsinghorst

optpragmas
{
{-# LANGUAGE PatternGuards #-}
}

imports
{
import CCO.Printing

import Data.Maybe
}

{
type Language = String
type Platform = String

type SourceAndTargetLanguage = (Language, Language)

type DiagTypeEnvironment = [(String, DiagType)]

data Diagnostic 
  = TyError    SourcePos DiagTypeEnvironment DiagType String
  | ScopeError SourcePos DiagTypeEnvironment          String

type Implementation = Either Platform Language
  
data DiagType
  -- Concrete Types
  = Type_Platform                         Platform
  | Type_Program                          Implementation
  | Type_Interpreter Language             Implementation 
  | Type_Compiler SourceAndTargetLanguage Implementation 
  
  -- Abstract Types
  | Type_Top
  | Type_Executor    Language                -- canExecuteLanguage
  | Type_Transformer SourceAndTargetLanguage -- canTransformLanguage
  
  | Type_Executable    Language              -- hasImplementationLanguage
  
instance Show DiagType where
  show (Type_Top)                          = "Top"
  show (Type_Platform m)                   = "Platform {!" ++ m ++ "!}"
  
  show (Type_Program           (Right m))  = "Program {"  ++ m ++  "}"
  show (Type_Program           (Left  m))  = "Program {!" ++ m ++ "!}"
  show (Type_Compiler (l1, l2) (Right m))  = "Compiler [" ++ l1 ++ "] ~> {" ++ l2 ++ "} / {"  ++ m ++  "}"
  show (Type_Compiler (l1, l2) (Left  m))  = "Compiler [" ++ l1 ++ "] ~> {" ++ l2 ++ "} / {!" ++ m ++ "!}" 
  show (Type_Interpreter l1    (Right l2)) = "Interpreter [" ++ l1 ++ "] ~> {" ++ l2 ++ "}"
  show (Type_Interpreter l1    (Left  l2)) = "Interpreter [" ++ l1 ++ "] ~> {!" ++ l2 ++ "!}"
  
  show (Type_Executor l1)                  = "Executor [" ++ l1 ++ "] ~> {!" ++ l1 ++ "!}"
  show (Type_Transformer (l1, l2))         = "Transformer [" ++ l1 ++ "] ~> {" ++ l2 ++ "}"
}

-- Position Information
  
attr Diag_ 
  inh   pos :: { SourcePos }
sem Diag
  | Diag        d.pos = @pos

-- Semantics
  
attr Diag Diag_
  syn   implementationLanguage :: { Either Platform Language }
  syn   canExecuteLanguage     :: { Maybe Language }
  syn   canTransformLanguage     :: { Maybe SourceAndTargetLanguage }
  
sem Diag_
  | Program     loc.canExecuteLanguage = Nothing
  | Compiler    loc.canExecuteLanguage = Nothing
  
  | Platform    loc.canExecuteLanguage = Just @m
  | Interpreter loc.canExecuteLanguage = Just @l
      
  | Execute     loc.canExecuteLanguage = @d1.canExecuteLanguage
  | Compile     loc.canExecuteLanguage = @d1.canExecuteLanguage

sem Diag
  | Use         lhs.canExecuteLanguage = fromJust (lookup @name @lhs.canExecuteLanguageList)
  
sem Diag_
  | Program     loc.canTransformLanguage = Nothing
  | Compiler    loc.canTransformLanguage = Just (@l1, @l2)
  
  | Platform    loc.canTransformLanguage = Nothing
  | Interpreter loc.canTransformLanguage = Nothing
      
  | Execute     loc.canTransformLanguage = @d1.canTransformLanguage
  | Compile     loc.canTransformLanguage = @d1.canTransformLanguage
  
sem Diag
  | Use         lhs.canTransformLanguage = fromJust (lookup @name @lhs.canTransformLanguageList)
  
sem Diag_
  | Program     loc.implementationLanguage = Right @l
  | Compiler    loc.implementationLanguage = Right @m
  
  | Platform    loc.implementationLanguage = Left  @m
  | Interpreter loc.implementationLanguage = Right @m
      
  | Execute     loc.implementationLanguage = case @d2.implementationLanguage of
                                               Right l       -> Left l
                                               Left  m       -> Left m
  | Compile     loc.implementationLanguage = case @d2.canTransformLanguage of
                                               Just (l1, l2) -> Right l2
                                               Nothing       -> Left "<invalid>"
sem Diag
  | Use         lhs.implementationLanguage = fromJust (lookup @name @lhs.implementationLanguageList)



-- Type Checking

attr Diag Diag_ DiagBinds Diagram
  syn   typeDiagnostics use {++} { [] } :: { [Diagnostic] }

attr Diagram Diag Diag_
  syn   diagType                        :: { DiagType }
attr Diag Diag_ DiagBinds
  inh   diagType                        :: { DiagType }
  
sem Diag_
  | Program     lhs.diagType = mkProgramType  @implementationLanguage                    
  | Compiler    lhs.diagType = mkCompilerType @implementationLanguage @canTransformLanguage 
  
  | Platform    lhs.diagType = mkPlatformType @canExecuteLanguage  
  | Interpreter lhs.diagType = mkInterpreterType @implementationLanguage @canExecuteLanguage  
      
  | Execute     lhs.diagType = setImplementationLanguage @implementationLanguage @d1.diagType
  | Compile     loc.diagType = setImplementationLanguage @implementationLanguage @d1.diagType

sem Diag
  | Diag        loc.diagType = @d.diagType
  | Use         lhs.diagType = case (lookup @name @lhs.diagTypeList) of
                                Just typ -> typ
                                Nothing  -> Type_Top

sem Diagram
  | Diagram     loc.diagType = @d.diagType
                                
sem Diag_
  | Program     lhs.typeDiagnostics = []
  | Compiler    lhs.typeDiagnostics = []
  
  | Platform    lhs.typeDiagnostics = []
  | Interpreter lhs.typeDiagnostics = []
      
  | Execute     lhs.typeDiagnostics = @d1.typeDiagnostics ++ @d2.typeDiagnostics ++ (checkTyExecute @lhs.pos @lhs.diagTypeList @d1.diagType @d2.diagType)
  | Compile     lhs.typeDiagnostics = @d1.typeDiagnostics ++ @d2.typeDiagnostics ++ (checkTyCompile @lhs.pos @lhs.diagTypeList @d1.diagType @d2.diagType)

sem Diag
  | Use         lhs.typeDiagnostics = checkTyUse @pos @lhs.diagTypeList @name (lookup @name @lhs.diagTypeList)
  | Diag        lhs.typeDiagnostics = @binds.typeDiagnostics ++ @d.typeDiagnostics



-- Let bindings
  
attr Diag Diag_ DiagBinds
  inh   diagTypeList                :: { [(String, (DiagType)                     )] }
  inh   implementationLanguageList  :: { [(String, (Either Platform Language)     )] }
  inh   canExecuteLanguageList      :: { [(String, (Maybe Language)               )] }
  inh   canTransformLanguageList    :: { [(String, (Maybe SourceAndTargetLanguage))] }
attr DiagBinds
  syn   diagTypeList               use {++} { [] } :: { [(String, (DiagType)                     )] }
  syn   implementationLanguageList use {++} { [] } :: { [(String, (Either Platform Language)     )] }
  syn   canExecuteLanguageList     use {++} { [] } :: { [(String, (Maybe Language)               )] }
  syn   canTransformLanguageList   use {++} { [] } :: { [(String, (Maybe SourceAndTargetLanguage))] }

sem DiagBinds
  | BindCons    lhs.diagTypeList               = (@name, @d.diagType)               : @ds.diagTypeList
                lhs.implementationLanguageList = (@name, @d.implementationLanguage) : @ds.implementationLanguageList
                lhs.canExecuteLanguageList     = (@name, @d.canExecuteLanguage)     : @ds.canExecuteLanguageList
                lhs.canTransformLanguageList   = (@name, @d.canTransformLanguage)   : @ds.canTransformLanguageList
sem Diag
  | Diag        loc.diagTypeList               = @binds.diagTypeList               ++ @lhs.diagTypeList
                loc.implementationLanguageList = @binds.implementationLanguageList ++ @lhs.implementationLanguageList
                loc.canExecuteLanguageList     = @binds.canExecuteLanguageList     ++ @lhs.canExecuteLanguageList
                loc.canTransformLanguageList   = @binds.canTransformLanguageList   ++ @lhs.canTransformLanguageList

sem Diagram
  | Diagram     d.diagTypeList = []
                d.implementationLanguageList = []
                d.canTransformLanguageList = []
                d.canExecuteLanguageList = []

-- Flattening

attr Diagram Diag
  syn   flattenedDiag                     :: { Diag }
attr Diag Diag_
  syn   flattenedDiag_                    :: { Diag_ }

attr Diag Diag_ DiagBinds
  inh   flattenedDiagList                 :: { [(String, Diag_)] }
attr DiagBinds
  syn   flattenedDiagList use {++} { [] } :: { [(String, Diag_)] }

sem Diag
  | Diag        lhs.flattenedDiag  = Diag @pos BindNil $ @d.flattenedDiag_
  | Use         lhs.flattenedDiag  = Diag @pos BindNil $ @loc.flattenedDiag_
                loc.flattenedDiag_ = fromJust (lookup @name @lhs.flattenedDiagList)
sem Diag_
  | Program     lhs.flattenedDiag_ = Program @p @l
  | Platform    lhs.flattenedDiag_ = Platform @m
  | Compiler    lhs.flattenedDiag_ = Compiler @c @l1 @l2 @m
  | Interpreter lhs.flattenedDiag_ = Interpreter @i @l @m
  | Execute     lhs.flattenedDiag_ = Execute @d1.flattenedDiag @d2.flattenedDiag
  | Compile     lhs.flattenedDiag_ = Compile @d1.flattenedDiag @d2.flattenedDiag

sem DiagBinds
  | BindCons    lhs.flattenedDiagList = (@name, @d.flattenedDiag_) : @ds.flattenedDiagList

sem Diag
  | Diag        loc.flattenedDiagList = @binds.flattenedDiagList ++ @lhs.flattenedDiagList

sem Diagram
  | Diagram     d.flattenedDiagList = []

-- Naming

attr Diag Diag_
  syn   diagName                     :: { Ident }
attr Diag Diag_ DiagBinds
  inh   diagName                     :: { Ident }
  
attr Diag Diag_ DiagBinds
  inh   diagNameList                 :: { [(String, Ident)] }
attr DiagBinds
  syn   diagNameList use {++} { [] } :: { [(String, Ident)] }

  
sem Diag
  | Diag        loc.diagName    = @d.diagName
  | Use         lhs.diagName    = fromJust (lookup @name @lhs.diagNameList)

sem Diag_
  | Program     lhs.diagName    = @p
  | Platform    lhs.diagName    = @m
  | Compiler    lhs.diagName    = @c
  | Interpreter lhs.diagName    = @i
  | Execute     lhs.diagName    = @d1.diagName
  | Compile     loc.diagName    = @d1.diagName

sem Diagram
  | Diagram     loc.diagName    = @d.diagName
  
sem DiagBinds
  | BindCons    lhs.diagNameList = (@name, @d.diagName) : @ds.diagNameList
  
sem Diag
  | Diag        loc.diagNameList = @binds.diagNameList ++ @lhs.diagNameList

sem Diagram
  | Diagram     d.diagNameList = []
  
-- Type Checking Specific Diagrams
{
checkTyExecute :: SourcePos -> DiagTypeEnvironment -> DiagType -> DiagType -> [Diagnostic]
checkTyExecute pos env d1 d2 =
  case (coerceExecutable d1, coerceExecutor d2) of
    ( Just (Type_Executable l1), Just (Type_Executor l2) ) 
                                | l1 == l2 -> []
                                | l1 /= l2 -> [TyError pos env d1 $ "/Execute/: The `Executable` represented by the first diagram is written in language '" ++ l1 ++ "'"
                                                                           ++ " which is different from the execution language '" ++ l2 ++ "' of the `Executor`" 
                                                                           ++ " represented by the second diagram."]
    ( Just (Type_Executable l1), Nothing ) -> [TyError pos env d2 $ "/Execute/: The type inferred for the second diagram is not a subtype of `Executor`."]                                               
    ( Nothing                  , _       ) -> [TyError pos env d1 $ "/Execute/: The type inferred for the first diagram is not a subtype of `Executable`."
                                                                           ++ " Please make sure you aren't executing something which is already executing."]

checkTyCompile :: SourcePos -> DiagTypeEnvironment -> DiagType -> DiagType -> [Diagnostic]
checkTyCompile pos env d1 d2 =
  case (coerceExecutable d1, coerceTransformer d2) of
    ( Just (Type_Executable l1), Just (Type_Transformer (l2, _)) ) 
                                | l1 == l2 -> []
                                | l1 /= l2 -> [TyError pos env d1 $ "/Compile/: The `Executable` represented by the first diagram is written in language '" ++ l1 ++ "'"
                                                                           ++ " which is different from the source language '" ++ l2 ++ "' of the `Transformer`" 
                                                                           ++ " represented by the second diagram."]
    ( Just (Type_Executable l1), Nothing ) -> [TyError pos env d2 $ "/Compile/: The type inferred for the second diagram is not a subtype of `Compiler`."]                                               
    ( Nothing                  , _       ) -> [TyError pos env d1 $ "/Compile/: The type inferred for the first diagram is not a subtype of `Executable`."
                                                                           ++ " Please make sure you aren't transforming something which is already executing."]


checkTyUse :: SourcePos -> DiagTypeEnvironment -> String -> Maybe DiagType -> [Diagnostic]
checkTyUse pos env name (Just typ) = []
checkTyUse pos env name Nothing    = [ScopeError pos env $ "/Use/: variable '" ++ name ++ "' is not in scope."] 
}

{
coerceExecutor :: DiagType -> Maybe DiagType
coerceExecutor (Type_Interpreter l _) = Just $ Type_Executor l
coerceExecutor (Type_Platform m  )    = Just $ Type_Executor m
coerceExecutor _                      = Nothing

coerceTransformer :: DiagType -> Maybe DiagType
coerceTransformer (Type_Compiler t _) = Just $ Type_Transformer t
coerceTransformer _                   = Nothing

coerceExecutable :: DiagType -> Maybe DiagType
coerceExecutable (Type_Program       (Right m)) = Just $ Type_Executable m
coerceExecutable (Type_Compiler    _ (Right m)) = Just $ Type_Executable m
coerceExecutable (Type_Interpreter _ (Right m)) = Just $ Type_Executable m
coerceExecutable _                              = Nothing
}

{
setImplementationLanguage :: Implementation -> DiagType -> DiagType
setImplementationLanguage m (Type_Program       _ ) = Type_Program       $ m
setImplementationLanguage m (Type_Compiler t    _ ) = Type_Compiler t    $ m
setImplementationLanguage m (Type_Interpreter l _ ) = Type_Interpreter l $ m
setImplementationLanguage _   _                     = Type_Top
  
getImplementationLanguage :: DiagType -> Maybe Language
getImplementationLanguage (Type_Program       (Right m)) = Just m
getImplementationLanguage (Type_Compiler _    (Right m)) = Just m
getImplementationLanguage (Type_Interpreter _ (Right m)) = Just m
getImplementationLanguage _                              = Nothing

mkCompilerType :: Implementation -> Maybe SourceAndTargetLanguage -> DiagType
mkCompilerType m (Just l12) = Type_Compiler l12 m
mkCompilerType _ Nothing    = Type_Top

mkInterpreterType :: Implementation -> Maybe Language -> DiagType
mkInterpreterType l2 (Just l1) = Type_Interpreter l1 l2
mkInterpreterType _  Nothing   = Type_Top

mkPlatformType :: Maybe Language -> DiagType
mkPlatformType (Just m) = Type_Platform m
mkPlatformType Nothing  = Type_Top

mkProgramType :: Implementation -> DiagType
mkProgramType = Type_Program
}

{
createDiagFromType :: Ident -> DiagType -> Diag_
createDiagFromType nm (Type_Compiler (l1, l2) (Right m)) = Compiler nm l1 l2 m
createDiagFromType nm (Type_Compiler (l1, l2) (Left  m)) = Execute (wrapDiag $ Compiler nm l1 l2 m) (wrapDiag $ Platform m)
createDiagFromType nm (Type_Interpreter l     (Right m)) = Interpreter nm l m
createDiagFromType nm (Type_Interpreter l     (Left  m)) = Execute (wrapDiag $ Interpreter nm l m)  (wrapDiag $ Platform m)
createDiagFromType nm (Type_Program           (Right l)) = Program nm l
createDiagFromType nm (Type_Program           (Left  l)) = Execute (wrapDiag $ Program nm l) (wrapDiag $ Platform l)
createDiagFromType nm (Type_Platform          m        ) = Platform m
createDiagFromType nm (_                               ) = Platform "T"

wrapDiag :: Diag_ -> Diag
wrapDiag = Diag (SourcePos Stdin EOF) BindNil 
}


{
checkDiagram :: Diagram -> (Maybe (Diag, DiagType), [Diagnostic])
checkDiagram diagram =
  let semantics = sem_Diagram diagram
      results = wrap_Diagram semantics Inh_Diagram
      diagnostics = typeDiagnostics_Syn_Diagram results
      flattenedDiag = flattenedDiag_Syn_Diagram results
      diagType = diagType_Syn_Diagram results
  in (Just (flattenedDiag, diagType), diagnostics)
}
