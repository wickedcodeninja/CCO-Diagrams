-- (C) 2017 Wout Elsinghorst

optpragmas
{
{-# LANGUAGE PatternGuards #-}
}

imports
{
import CCO.Printing

import Data.Maybe
}

{
type Language = String
type Platform = String

type SourceAndTargetLanguage = (Language, Language)

type DiagTypeEnvironment = [(String, DiagType)]

data Diagnostic 
  = TyError    SourcePos DiagTypeEnvironment DiagType String
  | ScopeError SourcePos DiagTypeEnvironment          String

type Implementation = Either Platform Language
  
data DiagType 
  = Type_Top 
  | Type_Program                          Implementation
  | Type_Compiler SourceAndTargetLanguage Implementation -- canCompileLanguage
  | Type_Executor Language                Implementation -- canExecuteLanguage

instance Show DiagType where
  show (Type_Top)                          = "Top"
  show (Type_Program           (Right m))  = "Program {"  ++ m ++  "}"
  show (Type_Program           (Left  m))  = "Program {!" ++ m ++ "!}"
  show (Type_Compiler (l1, l2) (Right m))  = "Compiler [" ++ l1 ++ " ~> " ++ l2 ++ "] {"  ++ m ++  "}"
  show (Type_Compiler (l1, l2) (Left  m))  = "Compiler [" ++ l1 ++ " ~> " ++ l2 ++ "] {!" ++ m ++ "!}" 
  show (Type_Executor l1       (Right l2)) = "Executor [" ++ l1 ++ " ~> " ++ l2 ++ "]"
  show (Type_Executor l1       (Left  _))  = "Executor {!" ++ l1 ++ "!}" 
}

attr Diag Diag_
  syn   typeDiagnostics use {++} { [] } :: { [Diagnostic] }

attr Diag Diag_
  syn   diagType               :: { DiagType }
  syn   implementationLanguage :: { Either Platform Language }
  syn   canExecuteLanguage     :: { Maybe Language }
  syn   canCompileLanguage     :: { Maybe SourceAndTargetLanguage }
  
attr Diag_ 
  inh   pos :: { SourcePos }

sem Diag_
  | Program     lhs.diagType = mkProgramType  @implementationLanguage                    
  | Compiler    lhs.diagType = mkCompilerType @implementationLanguage @canCompileLanguage 
  
  | Platform    lhs.diagType = mkExecutorType @implementationLanguage @canExecuteLanguage  
  | Interpreter lhs.diagType = mkExecutorType @implementationLanguage @canExecuteLanguage  
      
  | Execute     lhs.diagType = replaceImplementationLanguage @implementationLanguage @d1.diagType
  | Compile     lhs.diagType = replaceImplementationLanguage @implementationLanguage @d1.diagType

  | Use         lhs.diagType = case (lookup @name @lhs.diagTypeList) of
                                Just typ -> typ
                                Nothing  -> Type_Top
  | Let         lhs.diagType = @d.diagType
  
sem Diag_
  | Program     lhs.typeDiagnostics = []
  | Compiler    lhs.typeDiagnostics = []
  
  | Platform    lhs.typeDiagnostics = []
  | Interpreter lhs.typeDiagnostics = []
      
  | Execute     lhs.typeDiagnostics = @d1.typeDiagnostics ++ @d2.typeDiagnostics ++ (checkTyExecute @lhs.pos @lhs.diagTypeList @d1.diagType @d2.diagType)
  | Compile     lhs.typeDiagnostics = @d1.typeDiagnostics ++ @d2.typeDiagnostics ++ (checkTyCompile @lhs.pos @lhs.diagTypeList @d1.diagType @d2.diagType)

  | Use         lhs.typeDiagnostics = checkTyUse @lhs.pos @lhs.diagTypeList @name (lookup @name @lhs.diagTypeList)
  | Let         lhs.typeDiagnostics = @binds.typeDiagnostics ++ @d.typeDiagnostics
  
sem Diag_
  | Program     loc.canExecuteLanguage = Nothing
  | Compiler    loc.canExecuteLanguage = Nothing
  
  | Platform    loc.canExecuteLanguage = Just @m
  | Interpreter loc.canExecuteLanguage = Just @l
      
  | Execute     loc.canExecuteLanguage = @d1.canExecuteLanguage
  | Compile     loc.canExecuteLanguage = @d1.canExecuteLanguage

  | Use         lhs.canExecuteLanguage = fromJust (lookup @name @lhs.canExecuteLanguageList)
  | Let         lhs.canExecuteLanguage = @d.canExecuteLanguage
  
sem Diag_
  | Program     loc.canCompileLanguage = Nothing
  | Compiler    loc.canCompileLanguage = Just (@l1, @l2)
  
  | Platform    loc.canCompileLanguage = Nothing
  | Interpreter loc.canCompileLanguage = Nothing
      
  | Execute     loc.canCompileLanguage = @d1.canCompileLanguage
  | Compile     loc.canCompileLanguage = @d1.canCompileLanguage
  
  | Use         lhs.canCompileLanguage = fromJust (lookup @name @lhs.canCompileLanguageList)
  | Let         lhs.canCompileLanguage = @d.canCompileLanguage
  
sem Diag_
  | Program     loc.implementationLanguage = Right @l
  | Compiler    loc.implementationLanguage = Right @m
  
  | Platform    loc.implementationLanguage = Left  @m
  | Interpreter loc.implementationLanguage = Right @m
      
  | Execute     loc.implementationLanguage = @d2.implementationLanguage
  | Compile     loc.implementationLanguage = case @d2.canCompileLanguage of
                                               Just (l1, l2) -> Right l2
                                               Nothing       -> Left "invalid"
                                               
  | Use         lhs.implementationLanguage = fromJust (lookup @name @lhs.implementationLanguageList)
  | Let         lhs.implementationLanguage = @d.implementationLanguage
                                        
sem Diag
  | Diag      lhs.typeDiagnostics        = @d.typeDiagnostics
  | Diag      lhs.implementationLanguage = @d.implementationLanguage
  | Diag      lhs.canExecuteLanguage     = @d.canExecuteLanguage
  | Diag      lhs.canCompileLanguage     = @d.canCompileLanguage

  | Diag      d.pos                       = @pos
  
  
  
attr DiagBinds
  syn   typeDiagnostics use {++} { [] } :: { [Diagnostic] }
attr Diag Diag_ DiagBinds
  inh   diagTypeList                :: { [(String, (DiagType)                     )] }
  inh   implementationLanguageList  :: { [(String, (Either Platform Language)     )] }
  inh   canExecuteLanguageList      :: { [(String, (Maybe Language)               )] }
  inh   canCompileLanguageList      :: { [(String, (Maybe SourceAndTargetLanguage))] }
attr DiagBinds
  syn   diagTypeList               use {++} { [] } :: { [(String, (DiagType)                     )] }
  syn   implementationLanguageList use {++} { [] } :: { [(String, (Either Platform Language)     )] }
  syn   canExecuteLanguageList     use {++} { [] } :: { [(String, (Maybe Language)               )] }
  syn   canCompileLanguageList     use {++} { [] } :: { [(String, (Maybe SourceAndTargetLanguage))] }

 
sem DiagBinds
  | BindCons    lhs.typeDiagnostics = @d.typeDiagnostics ++ @ds.typeDiagnostics
  
                lhs.diagTypeList               = (@name, @d.diagType)               : @ds.diagTypeList
                lhs.implementationLanguageList = (@name, @d.implementationLanguage) : @ds.implementationLanguageList
                lhs.canExecuteLanguageList     = (@name, @d.canExecuteLanguage)     : @ds.canExecuteLanguageList
                lhs.canCompileLanguageList     = (@name, @d.canCompileLanguage)     : @ds.canCompileLanguageList
sem Diag_
  | Let         d.diagTypeList               = @binds.diagTypeList               ++ @lhs.diagTypeList
                d.implementationLanguageList = @binds.implementationLanguageList ++ @lhs.implementationLanguageList
                d.canExecuteLanguageList     = @binds.canExecuteLanguageList     ++ @lhs.canExecuteLanguageList
                d.canCompileLanguageList     = @binds.canCompileLanguageList     ++ @lhs.canCompileLanguageList
                
{
checkTyExecute :: SourcePos -> DiagTypeEnvironment -> DiagType -> DiagType -> [Diagnostic]
checkTyExecute pos env d1 d2@(Type_Executor l2 _) | Just l1 <- getImplementationLanguage d1, l1 == l2  = [] -- Languages match!!
checkTyExecute pos env d1 d2@(Type_Executor l2 _) | Just l1 <- getImplementationLanguage d1, l1 /= l2  = [TyError pos env d1 $ "/Execute/: The implementation language '" ++ l1 ++ "' of the first diagram doesn't match the execution language '" ++ l2 ++ "' of the second diagram." ]
checkTyExecute pos env d1 d2                      | Just l1 <- getImplementationLanguage d1            = [TyError pos env d2 $ "/Execute/: The second diagram is not a valid execution unit for the language '" ++ l1 ++ "'."]
checkTyExecute pos env d1 d2                      | Nothing <- getImplementationLanguage d1            = [TyError pos env d1 $ "/Execute/: The first diagram is not executable."]

checkTyCompile :: SourcePos -> DiagTypeEnvironment -> DiagType -> DiagType -> [Diagnostic]
checkTyCompile pos env d1 (Type_Compiler (l2, _) _) | Just l1 <- getImplementationLanguage d1, l1 == l2  = [] -- Languages match!!
checkTyCompile pos env d1 (Type_Compiler (l2, _) _) | Just l1 <- getImplementationLanguage d1, l1 /= l2  = [TyError pos env d1 $ "/Compile/: The implementation language '" ++ l1 ++ "' of the first diagram doesn't match the compiler frontend language '" ++ l2 ++ "' of the second diagram." ]
checkTyCompile pos env d1 d2                        | Just l1 <- getImplementationLanguage d1            = [TyError pos env d2 $ "/Compile/: The second diagram is not a valid compiler for the language '" ++ l1 ++ "'."]
checkTyCompile pos env d1 d2                        | Nothing <- getImplementationLanguage d1            = [TyError pos env d1 $ "/Compile/: The first diagram is not compilable."]

checkTyUse :: SourcePos -> DiagTypeEnvironment -> String -> Maybe DiagType -> [Diagnostic]
checkTyUse pos env name (Just typ) = []
checkTyUse pos env name Nothing    = [ScopeError pos env $ "/Use/: variable '" ++ name ++ "' is not in scope."] 
}

{
replaceImplementationLanguage :: Implementation -> DiagType -> DiagType
replaceImplementationLanguage l1 (Type_Program     (Right _) ) = Type_Program     $ l1
replaceImplementationLanguage l1 (Type_Compiler l2 (Right _) ) = Type_Compiler l2 $ l1
replaceImplementationLanguage l1 (Type_Executor l2 (Right _) ) = Type_Executor l2 $ l1
replaceImplementationLanguage _   _                            = Type_Top
  
getImplementationLanguage :: DiagType -> Maybe Language
getImplementationLanguage (Type_Compiler _ (Right x)) = Just x
getImplementationLanguage (Type_Executor _ (Right x)) = Just x
getImplementationLanguage (Type_Program    (Right x)) = Just x
getImplementationLanguage _                           = Nothing

mkCompilerType :: Implementation -> Maybe SourceAndTargetLanguage -> DiagType
mkCompilerType m (Just l12) = Type_Compiler l12 m
mkCompilerType _ Nothing    = Type_Top

mkExecutorType :: Implementation -> Maybe Language -> DiagType
mkExecutorType l2 (Just l1) = Type_Executor l1 l2
mkExecutorType _  Nothing   = Type_Top

mkProgramType :: Implementation -> DiagType
mkProgramType m = Type_Program m
}

  
{
getTypeDiagnostics :: Diag -> [Diagnostic]
getTypeDiagnostics diag = typeDiagnostics_Syn_Diag (wrap_Diag (sem_Diag diag) (Inh_Diag [] [] [] []))
}
